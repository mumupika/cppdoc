---
title: Templates
---

import { Decl, DeclDoc } from "@components/decl-doc";
import { Desc, DescList, DocLink } from '@components/index';
import { Revision, RevisionBlock } from "@components/revision";
import { DR, DRList } from "@components/defect-report";
import { ParamDoc, ParamDocList } from "@components/param-doc";

A template is a C++ entity that defines one of the following:

- a family of classes (<DocLink dest="cpp/language/class_template">class template</DocLink>), which may be <DocLink dest="cpp/language/member_template">nested classes</DocLink>
- a family of functions (<DocLink dest="cpp/language/function_template">function template</DocLink>), which may be <DocLink dest="cpp/language/member_template">member functions</DocLink>


- <Revision since="C++11">an alias to a family of types (<DocLink dest="cpp/language/type_alias">alias template</DocLink>)</Revision>


- <Revision since="C++14">a family of variables (<DocLink dest="cpp/language/variable_template">variable template</DocLink>)</Revision>


- <Revision since="C++20">a concept (<DocLink dest="cpp/language/constraints">constraints and concepts</DocLink>)</Revision>

Templates are parameterized by one or more <DocLink dest="cpp/language/template_parameters">template parameters</DocLink>, of three kinds: type template parameters, constant template parameters, and template template parameters.

When template arguments are provided, or, for <DocLink dest="cpp/language/function_template#Template_argument_deduction">function</DocLink> <Revision since="C++17">and <DocLink dest="cpp/language/class_template_argument_deduction">class</DocLink></Revision> templates only, deduced, they are substituted for the template parameters to obtain a *specialization* of the template, that is, a specific type or a specific function lvalue.

Specializations may also be provided explicitly: <DocLink dest="cpp/language/template_specialization">full specializations</DocLink> are allowed for class<Revision since="C++14">, <DocLink dest="cpp/language/template_specialization">variable</DocLink></Revision> and function templates, <DocLink dest="cpp/language/partial_specialization">partial specializations</DocLink> are only allowed for class templates<Revision since="C++14"> and <DocLink dest="cpp/language/partial_specialization">variable templates</DocLink></Revision>.

When a class template specialization is referenced in context that requires a complete object type, or when a function template specialization is referenced in context that requires a function definition to exist, the template is *instantiated* (the code for it is actually compiled), unless the template was already explicitly specialized or explicitly instantiated. Instantiation of a class template does not instantiate any of its member functions unless they are also used. At link time, identical instantiations generated by different translation units are merged.

The definition of a class template must be visible at the point of implicit instantiation, which is why template libraries typically provide all template definitions in the headers (e.g., [most boost libraries are header-only](https://www.boost.org/doc/libs/release/more/getting_started/unix-variants.html#header-only-libraries)).

## Syntax

<DeclDoc>
  <Decl slot="decl">
    ```cpp cxx-mark
    template </*$s:parameter-list*/> /*$s:requires-clause*//*$opt*//*$s:declaration*/
    ```
  </Decl>
</DeclDoc>

<DeclDoc>
  <Decl slot="decl">
    ```cpp cxx-mark
    export template </*$s:parameter-list*/> /*$s:requires-clause*//*$opt*//*$s:declaration*/
    ```
  </Decl>
  <Revision until="C++11"></Revision>
</DeclDoc>

<DeclDoc>
  <Decl slot="decl">
    ```cpp cxx-mark
    template </*$s:parameter-list*/> concept /*$s:concept-name*/ = /*$s:constraint-expression*/;
    ```
  </Decl>
  <Revision since="C++20"></Revision>
</DeclDoc>


<ParamDocList>
  <ParamDoc name="parameter-list">
    a non-empty comma-separated list of the <DocLink dest="/cpp/language/template_parameters">template parameters</DocLink>, each of which is either <DocLink dest="/cpp/language/template_parameters#Constant_template_parameters">constant parameter</DocLink>, a <DocLink dest="/cpp/language/template_parameters#Type_template_parameters">type parameter</DocLink>, a <DocLink dest="/cpp/language/template_parameters#Template_template_parameters">template parameter</DocLink><Revision since="C++11">, or a <DocLink dest="/cpp/language/parameter_pack">parameter pack</DocLink> of any of those</Revision>.
  </ParamDoc>
  <ParamDoc name="requires-clause">
    <Revision since="C++20">a <DocLink dest="/cpp/language/constraints#requires-clauses">requires-clause</DocLink> that specifies the <DocLink dest="/cpp/language/constraints">constraints</DocLink> on the template arguments.</Revision>
  </ParamDoc>
  <ParamDoc name="declaration">
    declaration of a <DocLink dest="/cpp/language/class_template">class (including struct and union)</DocLink>, a <DocLink dest="/cpp/language/member_template">member class or member enumeration type</DocLink>, a <DocLink dest="/cpp/language/function_template">function</DocLink> or <DocLink dest="/cpp/language/member_template">member function</DocLink>, a static data member at namespace scope<Revision since="C++14">, a <DocLink dest="/cpp/language/variable_template">variable or static data member at class scope</DocLink></Revision>, <Revision since="C++11">or an <DocLink dest="/cpp/language/type_alias">alias template</DocLink></Revision>. It may also define a <DocLink dest="/cpp/language/template_specialization">template specialization</DocLink>.
  </ParamDoc>
  <ParamDoc name="concept-name constraint-expression">
    see constraints and concepts
  </ParamDoc>
</ParamDocList>

<RevisionBlock until="C++11">export was an optional modifier which declared the template as exported (when used with a class template, it declared all of its members exported as well). Files that instantiated exported templates did not need to include their definitions: the declaration was sufficient. Implementations of export were rare and disagreed with each other on details. </RevisionBlock>
> This section is incomplete.\
> **Reason:** core syntax, template parameters, and instantiations, take content common between class_template and function_template

## Template identifiers

A template identifier has one of the following syntaxes:

<DeclDoc>
  <Decl slot="decl">
    ```cpp cxx-mark
    /*$s:template-name*/</*$s:template-argument-list*//*$opt*/>
    ```
  </Decl>

  A *simple template identifier*.
</DeclDoc>
<DeclDoc>
  <Decl slot="decl">
    ```cpp cxx-mark
    operator /*$s:op*/</*$s:template-argument-list*//*$opt*/>
    ```
  </Decl>

  An operator function template identifier.
</DeclDoc>
<DeclDoc>
  <Decl slot="decl">
    ```cpp cxx-mark
    operator "" /*$s:identifier*/</*$s:template-argument-list*//*$opt*/>
    ```
  </Decl>

  A literal operator function template identifier. <Revision since="C++11" traits={[{ trait: "deprecated", since:"C++23"}]}></Revision>
</DeclDoc>
<DeclDoc>
  <Decl slot="decl">
    ```cpp cxx-mark
    operator user-defined-string-literal</*$s:template-argument-list*//*$opt*/>
    ```
  </Decl>

  A user-defined string literal operator. <Revision since="C++11"></Revision>
</DeclDoc>


<ParamDocList>
  <ParamDoc name="template-name">
    an <DocLink dest="/cpp/language/name">identifier</DocLink> that names a template
  </ParamDoc>
  <ParamDoc name="op">
    an <DocLink dest="/cpp/language/operators">overloadable operator</DocLink>
  </ParamDoc>
  <ParamDoc name="identifier">
    an identifier
  </ParamDoc>
  <ParamDoc name="user-defined-string-literal">
    `""` followed by an identifier
  </ParamDoc>
</ParamDocList>



A simple template identifier that names a class template specialization names a class.

A template identifier that names an alias template specialization names a type.

A template identifier that names a function template specialization names a function.

If all following conditions are satisfied, a template identifier is *valid*:

- There are at most as many arguments as there are parameters<Revision since="C++11"> or a parameter is a template <DocLink dest="cpp/language/parameter_pack">parameter pack</DocLink></Revision>
- There is an argument for each non-deducible<Revision since="C++11"> non-pack</Revision> parameter that does not have a default template argument
- Each template argument matches the corresponding template parameter
- Substitution of each template argument into the following template parameters (if any) succeeds

- <Revision since="C++20"> If the template identifier is <DocLink dest="/cpp/language/dependent_name">non-dependent</DocLink>, the associated constraints are satisfied as specified below</Revision>

An invalid simple template id is a compile-time error, unless it names a function template specialization (in which case <DocLink dest="cpp/language/sfinae">SFINAE</DocLink> may apply).

```cpp
template<class T, T::type n = 0>
class X;

struct S
{
    using type = int;
};

using T1 = X<S, int, int>; // error: too many arguments
using T2 = X<>;            // error: no default argument for first template parameter
using T3 = X<1>;           // error: value 1 does not match type-parameter
using T4 = X<int>;         // error: substitution failure for second template parameter
using T5 = X<S>;           // OK
```

<RevisionBlock since="C++20">
When the `template-name` of a simple template id names a constrained non-function template or a constrained template template parameter, but not a member template that is a member of an unknown specialization, and all template arguments in the simple template id are non-dependent, the associated constraints of the constrained template must be satisfied:

```cpp
template<typename T>
concept C1 = sizeof(T) != sizeof(int);

template<C1 T>
struct S1 {};

template<C1 T>
using Ptr = T*;

S1<int>* p;                      // error: constraints not satisfied
Ptr<int> p;                      // error: constraints not satisfied

template<typename T>
struct S2 { Ptr<int> x; };       // error, no diagnostic required

template<typename T>
struct S3 { Ptr<T> x; };         // OK, satisfaction is not required

S3<int> x;                       // error: constraints not satisfied

template<template<C1 T> class X>
struct S4
{
    X<int> x;                    // error, no diagnostic required
};

template<typename T>
concept C2 = sizeof(T) == 1;

template<C2 T> struct S {};

template struct S<char[2]>;      // error: constraints not satisfied
template<> struct S<char[2]> {}; // error: constraints not satisfied
```
</RevisionBlock>

If all following conditions are satisfied, two template identifiers are *same*:

- Their `template-name`s or operators refer to the same template
- Their corresponding type template arguments are the same type
- The template parameter values determined by their corresponding constant template arguments are <DocLink dest="cpp/language/template_parameters#Template_argument_equivalence">template-argument-equivalent</DocLink>
- Their corresponding template template arguments refer to the same template

Two template identifier that are the same refer to the same<Revision since="C++14"> variable,</Revision> class, or function.

## Templated entity

A *templated entity* (or, in some sources, "temploid") is any entity that is defined<Revision since="C++11"> (or, for a <DocLink dest="/cpp/language/lambda">lambda expression</DocLink>, created)</Revision> within a template definition. All of the following are templated entities:

- a class/function<Revision since="C++14">/variable</Revision> template


- <Revision since="C++20">a <DocLink dest="cpp/language/constraints">concept</DocLink> </Revision>

- a member of a templated entity (such as a non-template member function of a class template)
- an enumerator of an enumeration that is a templated entity
- any entity defined or created within a templated entity: a local class, a local variable, a friend function, etc

- <Revision since="C++11">the closure type of a <DocLink dest="cpp/language/lambda">lambda expression</DocLink> that appears in the declaration of a templated entity</Revision>

For example, in

```cpp
template<typename T>
struct A
{
    void f() {}
};
```

the function `A::f` is not a function template, but is still considered to be templated.

A *templated function* is a function template or a function that is templated.

A *templated class* is a class template or a class that is templated.

<Revision since="C++14">A *templated variable* is a variable template or a variable that is templated. </Revision>

## Keywords

<DocLink dest="cpp/keyword/template">template</DocLink>,
<DocLink dest="cpp/keyword/export">export</DocLink>

## Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards.

<DRList>
  <DR kind="cwg" id={2293} std="C++98">
    <Fragment slot="behavior-published">
      the rules of determining whether a template identifier is valid were not provided
    </Fragment>
    <Fragment slot="correct-behavior">
      provided
    </Fragment>
  </DR>
  <DR kind="cwg" id={2682} std="C++98">
    <Fragment slot="behavior-published">
      the definitions of templated function/template class (C++98)/templated variable (C++14) were missing
    </Fragment>
    <Fragment slot="correct-behavior">
      added
    </Fragment>
  </DR>
  <DR kind="cwg" id={2308} std="C++98">
    <Fragment slot="behavior-published">
      two template identifiers were different if their corresponding constant template arguments are not template-argument-equivalent
    </Fragment>
    <Fragment slot="correct-behavior">
      they are different if their corresponding constant template parameter values are not template-argument-equivalent
    </Fragment>
  </DR>
</DRList>

## See also

<DocLink dest="c/language/generic">C documentation</DocLink> for __Generic selection__