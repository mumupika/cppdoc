---
title: std::move
cppdoc:
  revision:
    since: C++11
---

import { CppHeader } from "@components/header";
import { Decl, DeclDoc } from "@components/decl-doc";
import { Desc, DescList } from "@components/desc-list";
import Missing from "@components/Missing.astro";
import { ParamDoc, ParamDocList } from "@components/param-doc";
import { Revision, RevisionBlock } from "@components/revision";

Defined in header <CppHeader name="utility" />.

<DeclDoc>
  <Decl slot="decl">
    <RevisionBlock since="C++11" until="C++14" noborder>
      ```cpp
      template <typename T>
      typename std::remove_reference<T>::type&& move(T&& t) noexcept;
      ```
    </RevisionBlock>
  </Decl>
  <Decl slot="decl">
    <RevisionBlock since="C++14" noborder>
      ```cpp
      template <class T>
      constexpr std::remove_reference_t<T>&& move(T&& t) noexcept;
      ```
    </RevisionBlock>
  </Decl>

  `std::move` is used to _indicate_ that an object `t` may be "moved from", i.e. allowing the efficient transfer of resources from `t` to another object.

  In particular, `std::move` produces an <Missing>xvalue expression</Missing> that identifies its argument `t`. It is exactly equivalent to a `static_cast` to an rvalue reference type.
</DeclDoc>

## Parameters

<ParamDocList>
  <ParamDoc name="t">
    the object to be moved
  </ParamDoc>
</ParamDocList>

## Return value

`static_cast<typename std::remove_reference<T>::type&&>(t)`

## Notes

The functions that accept rvalue reference parameters (including <Missing>move constructors</Missing>, <Missing>move assignment operators</Missing>, and regular member functions such as <Missing>`std::vector::push_back`</Missing>) are selected, by <Missing>overload resolution</Missing>, when called with <Missing>rvalue</Missing> arguments (either <Missing>prvalues</Missing> such as a temporary object or <Missing>xvalues</Missing> such as the one produced by `std::move`). If the argument identifies a resource-owning object, these overloads have the option, but aren't required, to _move_ any resources held by the argument. For example, a move constructor of a linked list might copy the pointer to the head of the list and store `nullptr` in the argument instead of allocating and copying individual nodes.

Names of <Missing>rvalue reference</Missing> variables are <Missing>lvalues</Missing> and have to be converted to <Missing>xvalues</Missing> to be bound to the function overloads that accept rvalue reference parameters, which is why <Missing>move constructors</Missing> and <Missing>move assignment operators</Missing> typically use `std::move`:

```cpp
// Simple move constructor
// the expression "arg.member" is lvalue
A(A&& arg) : member(std::move(arg.member)) {}
 
// Simple move assignment operator
A& operator=(A&& other) {
  member = std::move(other.member);
  return *this;
}
```

One exception is when the type of the function parameter is a <Missing>forwarding reference</Missing> (which looks like an rvalue reference to type template parameter), in which case <Missing>`std::forward`</Missing> is used instead.

Unless otherwise specified, all standard library objects that have been moved from are placed in a "valid but unspecified state", meaning the object's class invariants hold (so functions without preconditions, such as the assignment operator, can be safely used on the object after it was moved from):

```cpp
std::vector<std::string> v;
std::string str = "example";
v.push_back(std::move(str)); // str is now valid but unspecified
str.back(); // undefined behavior if size() == 0: back() has a precondition !empty()
if (!str.empty())
  str.back(); // OK, empty() has no precondition and back() precondition is met
 
str.clear(); // OK, clear() has no preconditions
```

Also, the standard library functions called with xvalue arguments may assume the argument is the only reference to the object; if it was constructed from an lvalue with std::move, no aliasing checks are made. However, self-move-assignment of standard library types is guaranteed to place the object in a valid (but usually unspecified) state:

```cpp
std::vector<int> v = {2, 3, 3};
v = std::move(v); // the value of v is unspecified
```

## Example

```cpp
#include <iomanip>
#include <iostream>
#include <string>
#include <utility>
#include <vector>
 
int main() {
  std::string str = "Salut";
  std::vector<std::string> v;

  // uses the push_back(const T&) overload, which means
  // we'll incur the cost of copying str
  v.push_back(str);
  std::cout << "After copy, str is " << std::quoted(str) << '\n';

  // uses the rvalue reference push_back(T&&) overload,
  // which means no strings will be copied; instead, the contents
  // of str will be moved into the vector. This is less
  // expensive, but also means str might now be empty.
  v.push_back(std::move(str));
  std::cout << "After move, str is " << std::quoted(str) << '\n';

  std::cout << "The contents of the vector are {" << std::quoted(v[0])
            << ", " << std::quoted(v[1]) << "}\n";
}
```

Possible output:

```
After copy, str is "Salut"
After move, str is ""
The contents of the vector are {"Salut", "Salut"}
```

## See also

<DescList>
  <Desc kind="function template">
    <Fragment slot="item">
      <RevisionBlock noborder since="C++11" vertical><Missing>`forward`</Missing></RevisionBlock>
    </Fragment>
    forwards a function argument and use the type template argument to preserve its value category
  </Desc>

  <Desc kind="function template">
    <Fragment slot="item">
      <RevisionBlock noborder since="C++11" vertical><Missing>`move_if_noexcept`</Missing></RevisionBlock>
    </Fragment>
    converts the argument to an xvalue if the move constructor does not throw
  </Desc>

  <Desc kind="function template">
    <Fragment slot="item">
      <RevisionBlock noborder since="C++11" vertical><Missing>`move`</Missing></RevisionBlock>
    </Fragment>
    moves a range of elements to a new location
  </Desc>
</DescList>
